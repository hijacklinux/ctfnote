---
layout: default
---
# ![](../img/hj.jpg)ARM汇编指令
>小贱提示： 程序中以点“.”开头的指令都是汇编器指令，是与汇编器相关的，不属于ARM指令集

## ![](../img/github26.png){cond}条件码

|  助记符   |  	标志   |   含义  |
| --- | --- | --- |
|  EQ   |    Z=1     |            相等            |
| ----- | ---------- | -------------------------- |
| NE    | Z=0        | 不相等                     |
| CS/HS | C=1        | 无符号数大于或等于         |
| CC/LO | C=0        | 无符号数小于               |
| MI    | N=1        | 负数                       |
| PL    | N=0        | 正数或0                    |
| VS    | V=1        | 溢出                       |
| VC    | V=0        | 没有溢出                   |
| HI    | C=1 && Z=0 | 无符号数大于               |
| LS    | C=0        或Z=1  | 无符号数小于等于 |
| GE    | N=V        | 有符号大于等于             |
| LT    | N!=V       | 有符号小于                 |
| LE    | Z=1        或 N!=V | 有符号小于等于   |
| GT    | Z=0 && N=V | 有符号大于                 |
| AL    | 任何       | 无条件执行（指令默认条件） |

## ![](../img/github27.png){S}改变标志位
S指定指令是否影响CPSR标志寄存器的值，如ADDS，SUBS
## ![](../img/github28.png){type}数据大小类型
type有（无type时为dword型）：

| 助记符 | 含义 |
| ------ | ---- |
| B| 	Byte型，举例用法，下同：LDRB R0,[R1]|
| BT| 	用户模式的Byte型|
| H| 	word型|
| SB| 	有符号Byte型|
| SH| 	有符号word型|
| T| 	用户模式dword|

## ![](../img/github1.png)LDR加载和STR存储

ldr加载指令格式（相当于x86中的mov xx,[ ]）：LDR{条件}{type}  目的寄存器，<存储器地址>
```
LDR R0，[R1] ； R0=[R1]，将R1中的值作为地址，将地址里面存的值复制给寄存器R0
LDR R0, 0x12345678 ；就是把0x12345678这个地址中的值存放到r0中。
```
STR用法类似LDR:STR{cond}{type} Rd,addr
```
STR R0，[R1] ； [R1]=R0，将R0里面的值，复制到以R1里面的值作为地址的内存里面。
```
ldr伪指令（相当于x86中的lea）：
```
LDR伪指令的形式是“LDR Rn,=expr”
ldr r0, =0x12345678；把0x12345678这个地址写到r0中
```

## ![](../img/github2.png)mov
#### 指令格式

MOV{条件}{S} 目的寄存器，源操作数

#### 指令详解

MOV指令可完成从另一个寄存器、被移位的寄存器或立即数赋值到目的寄存器。

其中S选项为指令的操作结果是否操作CPSR中的条件标志位，当没有S选项时指令不更新CPSR中的条件标志位结果。

#### 指令实例
```
MOV  R0,R1 ; R0 = R1;

MOV PC,R14 ;PC = R14;

MOV  R0,R1,LSL#3 ;R0=R1<<3;

MOV R0,#100      ;#表示数字，R0=100,十进制，如果十六进制的话#0x100
```
## ![](../img/github12.png)SWP
SWP用于寄存器与存储器之间数据交换
#### 格式：
SWP	{B}  {cond}  Rd,Rm,[Rn]

B:		可选的字节，有B则交换Byte大小，否则交换32位

Rd:	要从存储器中加载数据的寄存器

Rm:	写入数据到存储器的寄存器

Rn:	需要进行数据交换的存储器地址。Rn不能与Rd或Rm相同

如果Rd与Rm相同，可实现单个寄存器与存储器的数据交换
#### 举例：
SWP R1，R1，[R0]         #将R1寄存器与R0指向的存储单元的内容进行交换

SWPB R1，R2，[R0]		#从R0指向的存储单元读取一个Byte存入R1（高24位清零），然后将R2寄存器的字节内容存储到[R0]这个存储单元
## ![](../img/github3.png)MVN
>小贱提示：
>
>可以理解为move not，即将立即数或寄存器按位取反后传送到目标寄存器

格式：
MVN {cond} {S} Rd,op2

举例：

MVN R0，#0xFF					//R0=0xFFFFFF00

MVN R0，R2						//将R2寄存器数据取反后存入R1寄存器
## ![](../img/github4.png)LDM批量数据加载(恢复现场用)
格式：LDM{cond}{type} Rn{!},regs{^}   ;[Rn]的值给regs

!：若选用了此后缀，则当指令执行完毕后，将最后的地址写入基址寄存器Rn中

{^}：当 regs 中不包含 PC 时，该后缀用于指示指令所用的寄存器为用户模式下的寄存器，否则指示指令执行时，将寄存器 SPSR 的值复制到 CPSR中

功能：从一片连续的内存单元读取数据到各个寄存器中，内存单元的起始地址为基址寄存器 Rn 的值，各个寄存器由寄存器列表 regs 表示。

该指令一般用于多个寄存器数据的出栈。

type 字段种类：

|   简写  |  英文解释   |   含义  |
| --- | --- | --- |
| IA	| 	Increase After		| 每次传送后地址加 4。|
| IB	| 	Increase Before		| 每次传送前地址加 4。|
| DA | Decrease After		| 每次传送后地址减 4。|
| DB| 	Decrease Befor		| 每次传送前地址减 4。|
| FD	| 	Full Decrease		| 	满递减堆栈。|
| ED| 	Empty Decrease		| 空递减堆栈。|
| FA	|  							| 满递增堆栈。|
| EA	| 							| 空递增堆栈。|

注意：有一个约定，编号低的寄存器在存储数据或者加载数据时对应于存储器的低地址。

恢复现场：
LDMFD SP!,{R1-R7,LR}
或
LDMFD SP!,{R1-R7,PC}
## ![](../img/github5.png)STM批量数据存储(保存现场用)
格式：STM{cond}{type>} Rn{!},regs{^};

功能：将各个寄存器的值存入一片连续的内存单元中，内存单元的起始地址为基址寄存器 Rn 的值，各个寄存器由寄存器列表 regs 表示。

该指令一般用于多个寄存器数据的入栈。

{^}：指示指令所用的寄存器为用户模式下的寄存器。

type 字段种类同上

注意：有一个约定，编号低的寄存器在存储数据或者加载数据时对应于存储器的低地址。

例如：

STMEA R13!,{R0-R12,PC}

;将寄存器 R0~R12 以及程序计数器 PC 的值保存到 R13 指示的堆栈中，！表示R13值更新

保存现场：

STMFD SP!,{R1-R7,LR}
## ![](../img/github6.png)运算指令
#### add
ADD : 加法

ADD{条件}{S} , , dest = op_1 + op_2

ADD 将把两个操作数加起来，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值:
```
ADD R0, R1, R2 ; R0 = R1 + R2
ADD R0, R1, #256 ; R0 = R1 + 256
ADD R0, R2, R3,LSL#1 ; R0 = R2 + (R3 << 1)
```
加法可以在有符号和无符号数上进行。
带进位的加法ADC
#### sub
SUB : 减法

SUB{条件}{S} , , dest = op_1 - op_2

SUB 用操作数 one 减去操作数 two，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值:
```
SUB R0, R1, R2 ; R0 = R1 - R2
SUB R0, R1, #256 ; R0 = R1 - 256
SUB R0, R2, R3,LSL#1 ; R0 = R2 - (R3 << 1)
```
减法可以在有符号和无符号数上进行。

带进位的减法SBC
#### mul
MUL : 乘法

这两个指令与普通算术指令在对操作数的限制上有所不同:

给出的所有操作数、和目的寄存器必须为简单的寄存器。

你不能对操作数 2 使用立即值或被移位的寄存器。

目的寄存器和操作数 1 必须是不同的寄存器。

最后，你不能指定 R15 为目的寄存器

带累加的乘法MLA

MUL{条件}{S} , , dest = op_1 * op_2

MUL 提供 32 位整数乘法。如果操作数是有符号的，可以假定结果也是有符号的。
#### AND/ORR/EOR/BIC逻辑运算
AND/ORR/EOR/BIC {cond} {S} Rd,Rn,op2

AND：与

AND R0，R0，#1		//R0=R0 and 1

ORR：或

ORR R0,R0,#0x0F  		//R0=R0 or 0xF

EOR:异或

BIC：将op2取反的结果与Rn相与，之后的结果保存在Rd中
//即Rd=Rn AND not (op2)
#### LSL/LSR/ASR/ROR/RRX位移
移位操作在 ARM 指令集中不作为单独的指令使用

ARM指令集的 5  种位移操作：

|  指令   |   解释  |   用法  |
| --- | --- | --- |
| LSL 	| 	逻辑左移 | Rx，LSL op1|
| LSR 	| 	逻辑右移 |  Rx，LSR op1|
| ASR 	| 	算术右移 | Rx，ASR op1|
| ROR 	| 	循环右移 | Rx，ROR op1|
| RRX 		| 带扩展的循环右移| Rx，RRX|

## ![](../img/github7.png)跳转指令
#### B跳转指令
格式：B{cond} addr;

功能： PC= PC+ addr 左移两位

addr 的值是相对当前 PC（即寄存器 R15）的值的一个偏移量，而不是一个绝对地址，它是 24 位有符号数。实际地址的值由汇编器来计算.

addr 的值有符号扩展为 32 位后，左移两位，然后与 PC 值相加，即得到跳转的目的地址。
跳转的范围为-32MB~+32MB。
例如：

B exit; 程序跳转到标号 exit 处

#### BL  带返回的跳转指令
简单理解，就是call
#### BLX  带返回和状态切换的跳转指令
格式：BLX addr;或 BLX Rn;

功能：处理器跳转到目标地址处，并将 PC（寄存器 R15）的值保存到 LR 寄存器（R14）中。

若为第二种格式，寄存器 Rn 的值是转移目标，Rn 的第 0 位拷贝到 CPSR 中的 T 位（决定是继续执行还是切换到 Thumb 指令），[31:0]位移入 PC；

如果 Rn[0]是 1，则处理器切换执行 Thumb 指令，并在 Rn 中的地址开始执行，但是需将最低为清零；

如果 Rn[0]是 0，则处理器继续执行 ARM 指令，并在 Rn 中的地址处开始执行，但需将 Rn[1]清零。

该指令用于子程序调用和程序状态的切换。
例如：
```
BLX T16; 跳转到标号 T16 处执行，T16 后面的指令为 Thumb 指令
…
CODE16
T16 后面指令为 Thumb 指令
…
```
#### BX  带状态切换的跳转指令
格式：BX Rn;

功能：处理器跳转到目标地址处，从那里继续执行；

目标地址为寄存器 Rn 的值和 0xFFFFFFFE 作与操作的结果。

目标地址处的指令可以是 ARM 指令，也可以是 Thumb 指令。
例如：
```
ADR R0,exit ;标号 exit 处的地址装入 R0 中
BX R0 ;跳转到 exit 处
```
## ![](../img/github8.png)cmp比较指令
格式：CMP{cond} Rn,op1;

功能：Rn-op1

该指令进行一次减法运算，但不存储结果，根据结果更新 CPSR 中条件标志位的值。

该指令不需要显式地指定 S 后缀来更改状态标志。其中，操作数 op1 为寄存器或立即数。

例如：
```
CMP R0,＃5
;计算 R0-5，根据结果设置条件标志位
ADDGT R0,R0,＃5
;如果 R0>5，则执行 ADDGT 指令
```
## ![](../img/github9.png)TEQ  相等测试指令
格式：TEQ{cond} Rn,op1;

功能： Rn EOR op1

将寄存器 Rn 的值和操作数 op1 所表示的值按位作逻辑异或操作，根据结果更新 CPSR 中条件标志位的值，但不存储结果。

用于检查寄存器 Rn 的值是否和 op1 所表示的值相等。

例如：
TEQ R0,＃5 ;判断 R0 的值是否和 5 相等
## ![](../img/github10.png)TST  位测试指令
格式：TST{cond} Rn,op1;

功能： Rn AND op1

根据结果更新 CPSR 中条件标志位的值，但不存储结果。
用于检查寄存器 Rn 是否设置了 op1 中相应的位。

例如：

TST R0，＃5
；测试 R0 中第 0 位和第 2 位是否为 1
## ![](../img/github11.png)CMN  反值比较指令

格式：CMN{cond} Rn,op1;

功能：同 CMP 指令，但寄存器 Rn 的值是和 op1 取负的值进行比较。

例如：

CMN R0,＃5 ;把 R0 与-5 进行比较

__原创文章，转载请注明转载自[http://www.8pwn.com](http://www.8pwn.com)__

[返回上一层](./reverse)
