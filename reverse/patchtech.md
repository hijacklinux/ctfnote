---
layout: default
---
# ![](../img/hj.jpg)补丁技术
>小贱提示： 有时候修改mov eax，4由于字节长度关系会覆盖下面指令，这时需要内嵌补丁：
>
>把会覆盖的代码放到下面填充部分，上面在加一个mov eax，4 ，然后在要修改的地方jmp 到填充位置，之后再jmp回去

## ![](../img/github4.png)文件补丁
```
适用于未加壳的程序，话说未加壳的程序直接修改保存就行
```
## ![](../img/github5.png)内存补丁
>loader和dll劫持


```
载入od后先运行一遍，直接ctr g 401000(90%的情况下是这个地址)，
如果一堆db xx，说明已经脱离了壳，删除分析即可，之后智能搜索字符串'未注册用户'，双击向上找跳转，特别注意software/软件名，这是注册表项，可判断访问了注册表，下个断，
重新运行后，忽略断点报错，api常用断点>取初始断点，意思是在程序已经解码与开始运行程序之间的空当下断，f9，断下了，有时需要多次f9才能到初始点，如何判断：看ctr b，如果不是add byte xxxx形式，说明已经解码，然后禁用堆栈断点，激活注册表项断点，（初始化断点目的就是寻找解码位置），f9

dll劫持补丁:勾选hook，user32，getactivewindow，生成类型随便选，生成
```
## ![](../img/github6.png)SMC补丁
>小贱提示：
>
>单层SMC和多层SMC，其实就是diy补数据
>
>下面以单层SMC作为举例，多层SMC补丁原理一样，想要详细了解的同学见看雪的加密与解密（第三版）531页

#### step1:找到跳转到入口点的命令
```
0040BCCE    popad
0040BCCF    jmp MenuUPX.00401210 //00401210 是eop,这个就是程序解压后准备跳转到OEP了

就在0040BCCF改成jmp到一个空白代码空间处，让程序修改想要修改的（diy补数据），修改好之后就再跳回到OEP
这里我有个想法，直接插件下初始断点，再diy补数据应该也可以
```
#### step2:找空白代码空间：
```
这段空间最好的位置就是各个区段中间的间隙
PEID查看区段，如UPX0，UPX1，.rsrc。外壳代码在UPX1中，外壳将解压后的原始代码映射到UPX0中，UPX1和.rsrc之间就有一块空白区间，可用于diy
这里前提是UPX1必须是可读写，可以去pe头修改读写属性
（dump找400000，右键指定pe头，找到第一个区块，看到charactoristics，把60000020改为E0000020就赋予了写权限了）
```
#### step3:补数据
```
例如UPX1从40BCD0开始就全是0了，就可以改成这样：
0040BCCF     jmp MenuUPX.0040B0E0
===========================
0040B0E0     mov word ptr [4011E3],006A
0040BCE9     jmp 0041210  //跳回OEP
```


__原创文章，转载请注明转载自[http://www.8pwn.com](http://www.8pwn.com)__

[返回上一层](./reverse)
