---
layout: default
---
# ![](../img/hj.jpg)ARM汇编寻址方式

## ![](../img/github13.png)立即数寻址
在立即数寻址中，操作数本身直接在指令中给出，取出指令也就获得了操作数，这个操作数也称为立即数。

#后接 0x 或&表示十六进制数，0b 表示二进制数，0d 或缺省表示十进制数。

例:
```
ADD R0，R1，＃5； R0=R1＋5
MOV R0，＃0x55； R0=0x55
其中：操作数 5，0x55 就是立即数，立即数在指令中要以“＃”为前缀，后面跟实际数值。
```
## ![](../img/github14.png)寄存器寻址
在寄存器寻址方式下，寄存器的值即为操作数。ARM 指令普遍采用此种寻址方式。

例：
```
ADD R0，R1，R2 ； R0=R1＋R2
MOV R0，R1 ； R0=R1
```
## ![](../img/github15.png)寄存器移位寻址
寄存器移位寻址的操作数由寄存器的数值做相应移位而得到。

移位的方式在指令中以助记符的形式给出，而移位的位数可用立即数或寄存器寻址方式表示。

例：
```
ADD R0，R1，R2，ROR ＃5；R0=R1＋（R2 循环右移 5 位）
MOV R0，R1，LSL R3；R0=（R1 逻辑左移 R3 位）
```
## ![](../img/github16.png)寄存器间接寻址
寄存器中的值为操作数的物理地址,而实际的操作数存放在存储器中。

例：
```
STR R0，[R1] ； [R1]=R0，将R0里面的值，复制到以R1里面的值作为地址的内存里面。
LDR R0，[R1] ； R0=[R1]，将R1中的值作为地址，将地址里面存的值复制给寄存器R0
```
## ![](../img/github17.png)基质变址寻址
将寄存器（称为基址寄存器）的值与指令中给出的偏移地址量相加，所得结果作为操作数的物理地址。

例：
```
LDR R0，[R1，＃5] ; R0=[R1+5]
LDR R0，[R1,R2] ; R0=[R1+R2]
```

## ![](../img/github18.png)相对寻址
相对寻址同基址变址寻址相似，区别只是将程序计数器 PC 作为基址寄存器，指令中的标记作为地址偏移量。

例：
```
BEQ process1
......
process1
……
```
## ![](../img/github19.png)多寄存器寻址
在多寄存器寻址方式中，一条指令可实现一组寄存器值的传送。

连续的寄存器间用“－”连接，否则用“，”分隔。

例:
```
LDMIA R0，{R1-R5}
；R1=[R0],R2=[R0+4],R3=[R0+8]
；R4=[R0+12]，R5=[R0+16]
指令中 IA 表示在执行完一次 Load 操作后，R0 自增 4。该指令将以 R0 为起始地址的 5 个字数据分别装入 R1，R2，R3，R4，R5 中。
多寄存器寻址一次可传送几个寄存器值，允许一条指令传送 16 个寄存器的任何子集或所有寄存器。
```
## ![](../img/github20.png)块拷贝寻址
块拷贝寻址可实现连续地址数据从存储器的某一位置拷贝到另一位置。

例:
```
LDMIA R0，{R1-R5}；
STMIA R1，{R1-R5}；
第一条指令从以 R0 的值为起始地址的存储单元中取出 5 个字的数据，
第二条指令将取出的数据存入以 R1 的值为起始地址的存储单元中。
实际上是多寄存器寻址的组合。
```
## ![](../img/github21.png)堆栈寻址

堆栈寻址用于数据栈与寄存器组之间批量数据传输。

当数据写入和读出内存的顺序不同时，使用堆栈寻址可以很好的解决这问题。

例：
```
STMFD R13!，{R0,R1,R2,R3,R4}；
LDMFD R13!，{R0,R1,R2,R3,R4}
第一条指令，将 R0－R4 中的数据压入堆栈，R13 为堆栈指针；
第二条指令，将数据出栈，恢复 R0－R4 原先的值。
```
存储器堆栈可分为两种：
向上生长：向高地址方向生长，称为递增堆栈
向下生长：向低地址方向生长，称为递减堆栈


__原创文章，转载请注明转载自[http://www.8pwn.com](http://www.8pwn.com)__

[返回上一层](./reverse)
