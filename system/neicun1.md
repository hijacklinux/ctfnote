---
layout: default
---
# ![](../img/hj.jpg)基础结构-内存

## ![](../img/github7.png)RAM

在 RAM 中，任意存储的任意数据块可以在任意时间访问，这也是随机存取（RandomAccess）这个名字的由来。

但 RAM 是易变的，这意味着如果计算机关闭，那么 RAM 中所有的数据都将丢失。
在讨论 Intel 的产品（x86）时，内存是按 32 位寻址的，这意味着处理器用来选择特定内存地址的地址总线为 32 位宽。

因此，x86 处理器最多能够寻址4 294 967 295 字节。
## ![](../img/github8.png)字节序
对于数值0x11223344

在基于 Intel 的处理器上           小端：高位高地址：0x44,0x33,0x22,0x11

在基于 Motorola 的处理器上   大端：高位低地址：0x11,0x22,0x33,0x44
## ![](../img/github9.png)内存分段
每个进程（在特别简化的情况下，可以认为是一个执行的程序）需要访问内存中属于自身的区域，因为没有人希望一个进程去改写另一个进程的数据。

因此，可将内存划分为小的段，按需分发给进程。

寄存器用来存储和跟踪进程当前维护的段 。

偏移寄存器（OffsetRegisters）用来跟踪关键的数据放在段中的位置。
## ![](../img/github10.png)内存中的程序
>小贱提示：
>
>在进程被载入内存中时，基本上被分裂成许多小的节（section） 。我们比较关注的是 6个主要的节

| 低地址  |   ——>      |    ——>      |    ——>    |     ——>     | ——>       |   高地址    |
| ------- | ------- | ------ | ---- | ------ | ---- | ----------- |
| .text节 | .data节 | .bss节 | 堆节 | 未使用 | 栈节 | 环境/参数节 |

#### .text节
.text 节基本上相当于二进制可执行文件的.text 部分，它包含了完成程序任务的机器指令。

该节标记为只读，如果发生写操作，会造成 segmentation fault。

在进程最初被加载到内存中开始，该节的大小就被固定。
#### .data节
.data 节用来存储初始化过的变量，如：

int a = 0;
该节的大小在运行时是固定的。
#### .bss节
栈下节（below stack section，即.bss）用来存储未初始化的变量，如：

int a;
该节的大小在运行时是固定的。
#### 堆节
堆节（heap section）用来存储动态分配的变量，位置从内存的低地址向高地址增长。

内存的分配和释放通过 malloc()和 free()函数控制。

例如，在运行时声明一个整数并分配内存，可能想到这样做：
```
int i = malloc (sizeof (int));     //动态分配一个整数（指针）变量，
//其值是分配之前该处内存的值
```
#### 栈节
栈节（stack section）用来跟踪函数调用（可能是递归的），

在大多数系统上从内存的高地址向低地址增长

栈增长的这种方式，导致了缓冲区溢出的可能性。
#### 环境/参数节
环境/参数节 （environment / arguments section） 用来存储系统环境变量的一份复制文件，进程在运行时可能需要。

例如，运行中的进程，可以通过环境变量来访问路径、shell 名称、主机名等信息。

该节是可写的， 因此在格式串 （format string） 和缓冲区溢出 （buffer overflow）攻击中都可以使用该节。

另外，命令行参数也保存在该区域中。

## ![](../img/github11.png)缓冲区
缓冲区（或缓存，buffer）是指这样的一个存储区域：
```
该区域用来接收和保存数据，直至进程对数据进行处理。
由于各个进程都有自己的缓冲区，所以保持各进程的缓冲区彼此无关是很重要的。
通过在进程内存的.data 或.bss 节分配内存，可以做到这一点。
```
要记住：
```
在内存分配之后，缓冲区的长度是固定的。
缓冲区可以保存任何预定义类型的数据，但我们目前将主要注意基于字符串的缓冲区，这种缓存区用来保存用户的输入和变量。
```
## ![](../img/github12.png)内存中的字符串
字符串数据只不过是内存中连续的字符构成的数组。

在内存中，是通过字符串第一个字符的地址来引用一个字符串。

字符串结束于空字符（C 语言中的\0） 。
## ![](../img/github13.png)指针
用于保存其他内存区的地址

例如，字符串是通过字符数组中第一个字符的地址进行引用，该地址值被称作一个指针。

因此 C 语言中一个字符串变量的声明如下：

char * str;    //代码的意思是，要提供 4 个字节来保存 str，而 str 是一个指向字符变量（可以是字符数组的第一个字节）的指针。

重要的是注意到，即使指针的大小是 4 个字节，但上述的声明并没有限定字符串的长度，因此编译器将认为该数据是未初始化的，会将其放到进程内存的.bss 节

以下是另一个例子，如果读者需要存储一个指针，指向内存中的一个整数，可以在 C程序中使用下述声明：

int * point1;       // 代码的意思是，要提供 4 个字节来保存 point1，这是个指向整型变量的指针。

为读取指针指向的内存地址中的值，可以使用*符号对指针反引用。

因此，如果打算输出上述代码中 point1 指向的整数的值，可以使用下述语句：

printf("%d", *point1);

其中*用来反引用 point1 指针，而 printf()函数则用来输出整数的值。
## ![](../img/github14.png)操作不同的内存区
我们来给出一个简单的例子，以声明如何在程序中使用内存：
```
/* memory.c */  // 注释，给出程序名
int index = 5;  // 存储在.data 节中的整数（已经初始化）
char * str; 	// 存储在.bss 节中的字符串（未初始化）
int nothing; 	// 存储在.bss 节中的整数（未初始化）
void funct1(int c){ 		// 大括号，标志 funct1 的开始
	int i=c; 						// 该变量存储在栈中
	str = (char*) malloc (10 * sizeof (char));    // 在堆中分配 10 个字符的空间
	strncpy(str, "abcde", 5); 	// 将 5 个字符"abcde"复制到 str
}  // funct1 的结束
main (){  	// main 函数，必需
	funct1(1); 		// main 用参数 1 调用 funct1
} 	//main 函数的结束
```
__原创文章，转载请注明转载自[http://www.8pwn.com](http://www.8pwn.com)__

[返回上一层](./system)
